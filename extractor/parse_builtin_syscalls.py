import os
import json
import argparse
import subprocess
from time import time


DATA_DIR = '../data'
DEBUG_LOG = os.path.join(DATA_DIR, 'debug.log')


builtin_syscall_sample = {
    "accept": [
        {
            "ID": 0,
            "NR": 43,
            "Name": "accept",
            "Args": {
                "fd": "sock",
                "peer": "ptr[out, sockaddr_storage]",
                "peerlen": "ptr[inout, len]"
            },
            "Return": "sock"
        },
        {
            "ID": 1,
            "NR": 43,
            "Name": "accept$alg",
            "Args": {
                "fd": "sock_alg",
                "peer": "const[0, const]",
                "peerlen": "const[0, const]"
            },
            "Return": "sock_algconn"
        }
    ],
    "eventfd": [
        {
            "ID": 199,
            "NR": 284,
            "Name": "eventfd",
            "Args": {
                "initval": "int32"
            },
            "Return": "fd_event"
        }
    ]
}


def parse_line_call(line):
    info = line.split(', ')
    ID = int(info[0].split('=')[1])
    NR = int(info[1].split('=')[1])
    Name = info[2].split('=')[1]
    CallName = info[3].split('=')[1]
    Return = info[5].split('=')[1]
    if Return == '<nil>':
        Return = None
    return (ID, NR, Name, CallName, Return)


def parse_line_arg(line):
    i1 = line.find('arg.Name')
    i2 = line.find('arg.Type')
    i3 = line.find('arg.HasDirection')
    arg_name = line[i1:i2-2].split('=')[1]
    arg_type = line[i2:i3-2].split('=')[1]
    return (arg_name, arg_type)


def parse_builtin_syscall():
    # suppose ../data/debug.log has been generated by syz-validator debug
    with open(DEBUG_LOG, 'r', encoding='utf-8') as f:
        lines = f.readlines()
    
    builtin_syscalls = {}
    call_dict = {}
    ID, NR, Name, CallName, Return = None, None, None, None, None
    for line in lines:
        line = line.strip()
        if line == '' in line:
            continue
        if 'Summary:' in line:
            break
        if 'ID=' in line:
            line = line[20:]
            pre_CallName = CallName
            if call_dict != {}:
                builtin_syscalls[pre_CallName].append(call_dict)
            ID, NR, Name, CallName, Return = parse_line_call(line)
            if CallName not in builtin_syscalls:
                print('Create key for %s'%CallName)
                builtin_syscalls[CallName] = []
            call_dict = {
                "ID": ID,
                "NR": NR,
                "Name": Name,
                "Args": {},
                "Return": Return
            }
        else:
            line = line[21:]
            arg_name, arg_type = parse_line_arg(line)
            call_dict["Args"][arg_name] = arg_type
    
    if call_dict != {}:
        builtin_syscalls[CallName].append(call_dict)
    
    return builtin_syscalls


def generate_debug_log(fuzzer_path):
    if not os.path.isfile(DEBUG_LOG):
        assert isinstance(fuzzer_path, str), "You must specify fuzzer path to generate debug log"
    elif fuzzer_path == None:
        return True
    syz_validator_bin = os.path.join(fuzzer_path, 'bin/syz-validator')
    parse_cmd = '%s debug %s'%(syz_validator_bin, DATA_DIR)
    result = subprocess.run(parse_cmd, shell=True, check=True)
    
    if result.returncode != 0: 
        print('returncode = %d'%result.returncode)
        exit(1)
    return True


if __name__ == '__main__':
    t0 = time()
    parser = argparse.ArgumentParser("parse debug log and extract builtin_syscalls")
    parser.add_argument("-s", "--fuzzer", type=str, help="path to SyzGPT-fuzzer")
    parser.add_argument("-o", "--out_dir", type=str, default="../data", help="output results to")
    args = parser.parse_args()
    
    generate_debug_log(args.fuzzer)
    builtin_syscalls = parse_builtin_syscall()
    with open(os.path.join(args.out_dir, 'builtin_syscalls.json'), 'w', encoding='utf-8') as f:
        json.dump(builtin_syscalls, f, indent=4)
        
    print('[%.2fs] generate builtin_syscalls.json at %s'%(time()-t0, args.out_dir))
    
    f1 = open(os.path.join(args.out_dir, 'builtin_syscalls.txt'), 'w', encoding='utf-8')
    f2 = open(os.path.join(args.out_dir, 'builtin_variants.txt'), 'w', encoding='utf-8')
    for c in builtin_syscalls:
        f1.write('%s\n'%c)
        for variant in builtin_syscalls[c]:
            f2.write('%s\n'%variant["Name"])
    f1.close()
    f2.close()
    print('[%.2fs] generate builtin_syscalls.txt and builtin_variants.txt at %s'%(time()-t0, args.out_dir))