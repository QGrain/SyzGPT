import os
import sys
sys.path.append('..')
import re
import json
import time
import requests
import tiktoken
from loguru import logger
try:
    from private_config import *
except ImportError:
    from config import *


SAMPLE_CASE1 = '''\
r0 = openat$rfkill(0xffffffffffffff9c, &AUTO='/dev/rfkill\x00', 0x801, 0x0)
write$rfkill(r0, &AUTO={0x0, 0x0, 0x3, 0x1, 0x0}, 0x8)'''

SAMPLE_CASE2 = '''\
# requires: arch=amd64
r0 = pkey_alloc(0x0, 0x0)
mmap(&(0x7f0000000000/0x1000)=nil, 0x1000, 0x3, 0x32, 0xffffffffffffffff, 0x0)
pkey_mprotect(&(0x7f0000000000/0x1000)=nil, 0x1000, 0x3, r0)
syz_pkey_set(r0, 0x3)
pipe(&(0x7f0000000000)={0x0, 0x0})  # EFAULT
syz_pkey_set(r0, 0x0)
pipe(&(0x7f0000000000)={0x0, 0x0})
pkey_free(r0)'''

SAMPLE_CASE3 = '''\
# This program mounts an empty ext4 filesystem that supports encryption
# (generated by 'mkfs.ext4 -O encrypt'), then adds an encryption key to that
# filesystem and creates an encrypted directory using that key.
syz_mount_image$ext4(&AUTO='ext4\x00', &AUTO='./mnt\x00', 0x0, &AUTO, 0x0, AUTO, &AUTO="$eJzs3TFoM2UcBvDnLomfk=")
r0 = openat(0xffffffffffffff9c, &AUTO='mnt', 0x0, 0x0)
ioctl$FS_IOC_ADD_ENCRYPTION_KEY(r0, 0xc0506617, &AUTO={@id={0x2, 0x0, @a='\x69\xb2\xf6\xed\xee\xe7\x20\xcc\xe0\x57\x79\x37\xeb\x8a\x67\x51', "00000000000000000000000000000000"}, 0x40, 0x0, "00000000000000000000000000000000", @a='\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a'})
mkdirat(0xffffffffffffff9c, &AUTO='mnt/encrypted_dir\x00', 0x1c0)
r1 = openat(0xffffffffffffff9c, &AUTO='mnt/encrypted_dir\x00', 0x0, 0x0)
ioctl$FS_IOC_SET_ENCRYPTION_POLICY(r1, 0x800c6613, &AUTO=@v2={0x2, @aes256, 0x0, "00000000", @a='\x69\xb2\xf6\xed\xee\xe7\x20\xcc\xe0\x57\x79\x37\xeb\x8a\x67\x51'})
r2 = openat(0xffffffffffffff9c, &AUTO='mnt/encrypted_dir/file\x00', 0x42, 0x180)
write(r2, &AUTO='foo', 0x3)'''


SECURE_CLIP = 50


def check_proxy(proxies):
    proxies_https = proxies['https'] if proxies is not None else 'æ— '
    try:
        response = requests.get("https://ipapi.co/json/",
                                proxies=proxies, timeout=4)
        data = response.json()
        print(f'Looking up the location of proxy, return: {data}')
        if 'country_name' in data:
            country = data['country_name']
            result = f"Proxy: {proxies_https}, Location: {country}"
        elif 'error' in data:
            result = f"Proxy: {proxies_https}, Location: Unknown, IP query limited"
        print(result)
        return result
    except:
        result = f"Proxy: {proxies_https}, Timeout, proxy maybe invalid"
        print(result)
        return result


def check_dir(d):
    if os.path.isdir(d):
        return True
    else:
        try:
            os.makedirs(d)
            return True
        except:
            return False


def check_exist(syscall, out_dir, tag):
    syscall_fn = syscall.replace('$', '_')
    dir_path = os.path.join(out_dir, tag)
    if os.path.isdir(dir_path):
        cases_fn = os.listdir(dir_path)
        for case_fn in cases_fn:
            if syscall_fn in case_fn:
                return True
    return False


def check_model(model):
    if model not in MAX_TOKEN:
        print('[FATAL] model %s is not in the config: MAX_TOKEN[%s] not found. exit(1)'%(model, model))
        exit(1)


def clip_msg(msg, clip_char_n):
    pop_cnt = 0
    for i in range(len(msg)):
        if len(msg[i-pop_cnt]['content']) > clip_char_n:
            msg[i-pop_cnt]['content'] = msg[i-pop_cnt]['content'][clip_char_n:]
            break
        else:
            clip_char_n -= len(msg[i-pop_cnt]['content'])
            msg.pop(i-pop_cnt)
            pop_cnt += 1
    print('[INFO] clipped %d strs'%clip_char_n)
    
    
def load_man_doc(syscall, sections):
    cur_path = os.path.abspath(__file__)
    proj_dir = os.path.dirname(os.path.dirname(cur_path))
    doc_path = os.path.join(proj_dir, 'crawler/docs', '%s.json'%syscall)
    
    with open(doc_path, 'r', encoding='utf-8') as f:
        doc_dict = json.load(f)
    
    doc_str = ''
    for sec in sections:
        try:
            doc_str += doc_dict[sec]
        except:
            pass
    return doc_str


def read_prog(prog_path):
    prog_str = ''
    with open(prog_path, 'r', encoding='utf-8') as f:
        lines = f.readlines()
        for line in lines:
            if line and line[0] == '#':
                continue
            prog_str += line
    return prog_str.strip()


def count_tokens_for_model(string, model_name):
    '''Return the number of tokens in a text string, passing GPT model name'''
    enc = tiktoken.encoding_for_model(model_name)
    return len(enc.encode(string))


def init_logger(log_file='default_{time:YYYY-MM-DD_HH-mm-ss}.log', level='DEBUG', pid=False, tid=False, ):
    pid_str = ' pid:{process}' if pid else ''
    tid_str = ' tid:{thread}' if tid else ''

    # remove the default console logger sink and re-add it
    logger.remove(handler_id=None)
    logger.add(
        sink=sys.stdout,
        level=level,
        colorize=True,
        format="<green>{time:YYYY-MM-DD HH:mm:ss.SSS}</green> | <level>{level: <8}</level> |<cyan>%s</cyan><cyan>%s</cyan> <cyan>{name}</cyan>:<cyan>{function}</cyan> @ <cyan>{file}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>"%(pid_str, tid_str)
    )

    # log to file
    logger.add(
        sink=log_file,
        level=level,
        encoding="utf-8",
        enqueue=True,
        format="{time:YYYY-MM-DD HH:mm:ss.SSS} | <level>{level: <8}</level> |%s%s {name}:{function} at {file}:{line} - {message}"%(pid_str, tid_str)
    )


def replace_unprintables(s):
    new_s = ''
    for c in s:
        if not c.isprintable() and c != chr(0x0a):
            new_s += '\\x{:02x}'.format(ord(c))
        else:
            new_s += c
    return new_s


def extract_program_content(response_text):
    '''For the generation results of local LLMs'''
    prog_content = ''
    prog_start = 0
    for line in response_text.split('\n'):
        line = line.strip()
        if line == '' or line[0] == '#':
            continue
        if '(' in line or ')' in line:
                if prog_start == 0:
                    prog_start = 1
                prog_content += '%s\n'%line
        elif prog_start == 1:
            break
        if line[:5] == 'User:':
            break
    return prog_content


def extract_programs(response_text, syscall, out_dir, suffix, force_fn=None, filter_for_local=False):
    check_dir(out_dir)
    if filter_for_local == True:
        response_text = extract_program_content(response_text)
    response_text = response_text.strip()
    if force_fn:
        with open(os.path.join(out_dir, force_fn), 'w', encoding='utf-8') as f:
            f.write('%s'%response_text)
        return
    if suffix != '.json':
        new_fn = syscall.replace('$', '_')
        with open(os.path.join(out_dir, '%s%s'%(new_fn, suffix)), 'w', encoding='utf-8') as f:
            f.write('%s'%response_text)
    else:
        with open(os.path.join(out_dir, '%s%s'%(syscall, suffix)), 'w', encoding='utf-8') as f:
            json.dump(response_text, f, indent=4)